"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[423],{7657:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=t(4848),i=t(8453);const s={sidebar_position:2},a="React",r={id:"react",title:"React",description:"Use UUID Correctly",source:"@site/docs/react.md",sourceDirName:".",slug:"/react",permalink:"/study-notes/docs/react",draft:!1,unlisted:!1,editUrl:"https://github.com/meiti-x/study-notes/tree/main/docs/react.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Javascript",permalink:"/study-notes/docs/Javascript"},next:{title:"typescript",permalink:"/study-notes/docs/typescript"}},c={},l=[{value:"Use UUID Correctly",id:"use-uuid-correctly",level:2},{value:"Create a folder for each component",id:"create-a-folder-for-each-component",level:2},{value:"extract to new component",id:"extract-to-new-component",level:2},{value:"Avoid overusing 3rd parties",id:"avoid-overusing-3rd-parties",level:2},{value:"React components and specific hooks for each",id:"react-components-and-specific-hooks-for-each",level:2},{value:"Component-specific hooks.",id:"component-specific-hooks",level:3},{value:"Always check for booleans in JSX",id:"always-check-for-booleans-in-jsx",level:2},{value:"Don\u2019t use inline functions if possible",id:"dont-use-inline-functions-if-possible",level:2},{value:"Fetching in useEffect",id:"fetching-in-useeffect",level:2},{value:"Put functions outside the component",id:"put-functions-outside-the-component",level:2},{value:"Don&#39;t use Context as global state manager",id:"dont-use-context-as-global-state-manager",level:2},{value:"Don\u2019t put JSX in custom hooks",id:"dont-put-jsx-in-custom-hooks",level:2},{value:"Don\u2019t import SVGs as JSX or directly in React",id:"dont-import-svgs-as-jsx-or-directly-in-react",level:2},{value:"Destructure Props on component call",id:"destructure-props-on-component-call",level:2},{value:"Avoid Nested Ternary Operators",id:"avoid-nested-ternary-operators",level:2},{value:"Use composition instead of Context",id:"use-composition-instead-of-context",level:2},{value:"Use virtualization for large lists",id:"use-virtualization-for-large-lists",level:2},{value:"Remove all the Listeners When Unmounting Components",id:"remove-all-the-listeners-when-unmounting-components",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"react",children:"React"}),"\n",(0,o.jsx)(n.h2,{id:"use-uuid-correctly",children:"Use UUID Correctly"}),"\n",(0,o.jsx)(n.p,{children:"according to docs, it's not good practice to generate keys while rendering. for example :"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-react",children:" import { v4 as uuidv4 } from 'uuid';\n\nfunction MyComponent() {\n  const items = ['Apple', 'Banana', 'Orange'];\n\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={uuidv4()}>{item}</li>\n      ))}\n    </ul>\n  );\n}\n\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"but, why?"})," This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data."]}),"\n",(0,o.jsx)(n.p,{children:"The better way is to generate keys on the data source not at the component level."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-react",children:" import { v4 as uuidv4 } from 'uuid';\n\nfunction MyComponent() {\n  const items = [\n    {\n        id:uuidv4(),\n        title:'Apple',\n    },\n    {\n        id:uuidv4(),\n        title:'Banana',\n    },\n    {\n        id:uuidv4(),\n        title:'Orange',\n    }\n];\n\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item.id}>{item.title}</li>\n      ))}\n    </ul>\n  );\n}\n\n"})}),"\n",(0,o.jsx)(n.p,{children:"even if you get dynamic value from server and there is no unique value for set as key, you should add them to list. for example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-react",children:"useEffect(() => {\n  getShopItems().then((res)=>addIdToData(res.data))\n}, []);\n\nfunction addIdToData(data){\n  data.map(item=>{\n    return {...item,id:uuidv4()}\n  })\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"create-a-folder-for-each-component",children:"Create a folder for each component"}),"\n",(0,o.jsxs)(n.p,{children:["Think of a component like being itself a ",(0,o.jsx)(n.strong,{children:"mini"})," application on the main application.\nIf the component contains business logic, extract it to a custom hook."]}),"\n",(0,o.jsx)(n.p,{children:"If the component needs to be split into subcomponents, create a \u201ccomponents\u201d folder inside the component folder and\nput each subcomponent in it."}),"\n",(0,o.jsx)(n.p,{children:"If there is a translation for it, add the folder with languages to it."}),"\n",(0,o.jsx)(n.p,{children:"If there is a need to create some helper function, put it in the \u201cutils\u201d files."}),"\n",(0,o.jsx)(n.p,{children:"In this way everything the component needs is enclosed in one folder specific to it."}),"\n",(0,o.jsx)(n.p,{children:"Placing all files under the same directory is a good way to make the code more comprehensible to others."}),"\n",(0,o.jsx)(n.p,{children:"It\u2019s easier to understand how different files relate to each other when they are grouped under the same directory."}),"\n",(0,o.jsx)(n.p,{children:"Instead, placing your component\u2019s related files by their types in some \u201ctype\u201d folders, is terribly cumbersome and not as clear to deal with as we need to jump from the component file to its hook, to its utility function or its subcomponents along all the app structure."}),"\n",(0,o.jsx)(n.h2,{id:"extract-to-new-component",children:"extract to new component"}),"\n",(0,o.jsx)(n.p,{children:"We know that we need to extract a new component whenever one component becomes too big.\nBut only extracting a new component because the component is too big does not mean much."}),"\n",(0,o.jsx)(n.p,{children:"A component can be as big as you want in terms of JSX and there is nothing wrong with that."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://kentcdodds.com/blog/when-to-break-up-a-component-into-multiple-components",children:"read more"})}),"\n",(0,o.jsx)(n.h2,{id:"avoid-overusing-3rd-parties",children:"Avoid overusing 3rd parties"}),"\n",(0,o.jsx)(n.p,{children:"Please avoid the usage of the libraries like lodash or ramda (even though it is more about functional programming than a syntactic sugar) for things that can be done with Vanilla JavaScript.\nJavaScrip has gone quite far and is now capable of many things that these helper libraries used to provide.\nThere are, of course, some valid use cases for these depending on the task, it just shouldn't be a default thing to reach for on a daily basis."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Supply_chain_attack",children:"supply chain attack"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/",children:"https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/"})}),"\n",(0,o.jsx)(n.h2,{id:"react-components-and-specific-hooks-for-each",children:"React components and specific hooks for each"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Never put any business logic into UI components!"})}),"\n",(0,o.jsx)(n.p,{children:"Pattern: do you have an useState,  useEffect or whatever hook into the UI component Bad!"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Extract all of that to a custom hook!"})}),"\n",(0,o.jsx)(n.p,{children:"Components returning JSX do not need and have no need to know about any business\nlogic, small or big!"}),"\n",(0,o.jsx)(n.p,{children:"This is the approach to create a nice,clean, structured and consistent React\nComponents for the Native and Web app."}),"\n",(0,o.jsx)(n.p,{children:"There are some principles behind the folder structure for top level components, reusable feature components and feature-agnostic UI components but\nthe way they are implemented internally is pretty much universal."}),"\n",(0,o.jsx)(n.p,{children:"Use Functional Components (or FC for short) exclusively in your codebase, alongside with React Hooks instead of the obsolete class components."}),"\n",(0,o.jsx)(n.p,{children:"So, everything in this guide implies the usage of functional components."}),"\n",(0,o.jsx)(n.h3,{id:"component-specific-hooks",children:"Component-specific hooks."}),"\n",(0,o.jsx)(n.p,{children:"For simple components, it's completely fine to just place everything into the component file itself, even if it's a simple data-fetching query hook and a bunch of intl's formatMessage calls."}),"\n",(0,o.jsx)(n.p,{children:"Once the component gets more complicated, with more and more data to fetch, more computed data to calculate, more static strings to format, effects to run, etc, the component might become quite a bit bloated - in this case it's advised to extract such logic into the component-specific hook."}),"\n",(0,o.jsx)(n.p,{children:"Component-specific hook is named strictly after the component (using the"}),"\n",(0,o.jsxs)(n.p,{children:["So, if there was some ",(0,o.jsx)(n.code,{children:"MyAwesomeComponent.tsx "}),"(or MyAwesomeComponent/index.tsx), the default component-specific hook file would be AwesomeComponent/useAwesomeComponent.ts."]}),"\n",(0,o.jsxs)(n.p,{children:["It is imported by the component using relative import path:\n",(0,o.jsx)(n.code,{children:"import { useMyAwesomeComponent } from './useMyAwesomeComponent';"}),"\nThis hook isn't necessarily for business-logic-heavy data-driven components only."]}),"\n",(0,o.jsx)(n.p,{children:"They can be very useful for complex UI-only components as well.\nPlease note that these hooks are intentionally not reusable, so while there are extremely rare cases where some other component borrows another component's component-specific hook, it's really specific to the original component it was created for."}),"\n",(0,o.jsx)(n.p,{children:"Don't move purely UI-specific things into a default component-specific hook. These include UI-level aspects like dealing with theme/palette, device screen sizes and such."}),"\n",(0,o.jsx)(n.p,{children:"It is possible to move those to a hook if that hook is specific to such UI-only aspects.\nComponent aspect-specific hooks."}),"\n",(0,o.jsx)(n.p,{children:"Component-specific hooks might get complicated over time (e.g., for complex components) and while this might mean the itself does too much on its own (remember"}),"\n",(0,o.jsx)(n.p,{children:"this hook is just a part of component), there might also be multiple component-specific hooks each tailored to a certain aspect of component's behaviour thus becoming component aspect-specific hooks."}),"\n",(0,o.jsxs)(n.p,{children:["While the default hook, useMyComponent, is generic in what it does for the component (anything except purely UI things), there might be hooks like: useMyComponentData that would be only concerned about fetching and preparing the data component should display ",(0,o.jsx)(n.code,{children:"useMyComponentAnimations"})," that would only be responsible for animations for the component useMyComponentEffects that would only run the component's effects (if there are many of those and they have quite a bit of logic)."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useMyComponent<ASPECT>"})," - any aspect can be extracted into a hook."]}),"\n",(0,o.jsx)(n.p,{children:"Note though, that since aspects can be reusable too, chances often are that a regular reusable hook independent from a component would work better."}),"\n",(0,o.jsx)(n.p,{children:"There can be any combination of component aspect-specific hooks and having a default/generic component-specific hook is not necessary."}),"\n",(0,o.jsx)(n.p,{children:"For example, if component is all about complex animations but doesn't really have anything else, consider only having the useMyComponentAnimations hook for it and handle everything else (e.g., if it needs a couple formatted translation strings besides the animations) in the component itself."}),"\n",(0,o.jsx)(n.p,{children:"Note of warning! Resist the temptation of putting unrelated stuff into aspect-specific hook."}),"\n",(0,o.jsx)(n.p,{children:'If a hook is strictly about "animations", don\'t think that "Ah, I already have some hook for the component, so one little nice data fetching query amidst the animation logic won\'t hurt anyone" - the thing is that it WILL, that query will get lost and someone will pull their hair wondering "where the hell that query is made from, this component only seems to have animations rolling O_o".'}),"\n",(0,o.jsx)(n.p,{children:"Note that a default component-specific hook, useMyComponent can have some animation logic along with some other bits, but the aspect-specific (e.g., useMyComponentAnimations) hook shouldn't have anything besides animations."}),"\n",(0,o.jsx)(n.h2,{id:"always-check-for-booleans-in-jsx",children:"Always check for booleans in JSX"}),"\n",(0,o.jsxs)(n.p,{children:["Always pay careful attention to what you are checking on the ",(0,o.jsx)(n.strong,{children:"left side"})," of a logical statement everywhere but especially in JSX."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-react",children:"// BAD\nundefined && ...\nnull && ...\narray.length && ...\n// GOOD\n!!undefined && ..\n!!null && ...\nArray.isArray(array) && !!array.length && ...\ntypeof someFunction === 'function' && ...\nObject.entries(obj).length > 0 && ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Is it a string or a number and you are sure it can't be anything else than a string or a number? Check them with the double bang always!\n",(0,o.jsx)(n.strong,{children:"Tip:"})," double bang ",(0,o.jsx)(n.code,{children:"!!"})," can be replaced with Boolean"]}),"\n",(0,o.jsx)(n.h2,{id:"dont-use-inline-functions-if-possible",children:"Don\u2019t use inline functions if possible"}),"\n",(0,o.jsx)(n.p,{children:"An inline function is an anonymous function. It will get created on every render."}),"\n",(0,o.jsx)(n.p,{children:"Creating new functions, same as creating new objects, comes with its costs."}),"\n",(0,o.jsx)(n.h2,{id:"fetching-in-useeffect",children:"Fetching in useEffect"}),"\n",(0,o.jsx)(n.p,{children:"Fetching data inside the useEffect hook might not fit the React mental model because it can lead to some issues and unexpected behavior. The React mental model encourages declarative, predictable, and efficient code. Fetching data inside useEffect can potentially break these principles in the following ways:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Non-declarative"}),": Fetching data inside useEffect often leads to imperative code that's harder to read and reason about. You might have to manually handle dependencies, manage loading and error states, and deal with cleanup. This can make your components more complex and less declarative."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Unpredictable"}),": Using useEffect for data fetching can result in unpredictable behavior due to the timing of when the effect runs. For example, if you fetch data inside a useEffect without an empty dependency array, the fetch request might be called more times than expected, leading to unnecessary requests and potential inconsistencies in your application's state."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Inefficient"}),": When you fetch data in useEffect, you might not be able to take full advantage of React's ability to skip rendering when props and state haven't changed. This can result in unnecessary re-renders, which can be inefficient and slow down your application."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Instead of fetching data in useEffect, it's recommended to use a library like React Query, SWR, or Axios with a custom hook to manage data fetching. These libraries provide a more declarative and efficient way to handle data fetching, helping you maintain the React mental model and keep your components clean and easy to reason about."}),"\n",(0,o.jsx)(n.h2,{id:"put-functions-outside-the-component",children:"Put functions outside the component"}),"\n",(0,o.jsx)(n.p,{children:"In the case when you create functions inside the component, the function will be recreated new on every render of the component.\nOf course, you can use the useCallback on it to preserve its identity but using useCallback has its own costs anyway.\nA much better approach is to put the function outside the component"}),"\n",(0,o.jsx)(n.h2,{id:"dont-use-context-as-global-state-manager",children:"Don't use Context as global state manager"}),"\n",(0,o.jsx)(n.p,{children:"n"}),"\n",(0,o.jsx)(n.h2,{id:"dont-put-jsx-in-custom-hooks",children:"Don\u2019t put JSX in custom hooks"}),"\n",(0,o.jsxs)(n.p,{children:["Custom hooks should be used only for ",(0,o.jsx)(n.strong,{children:"business logic"}),".\nIf you add JSX in a custom hook that is no longer a custom hook but a component.\nAnd it is not used properly because it ispulled in another component at the top level. This is about good practices and consistency rather than performance or functionality."]}),"\n",(0,o.jsx)(n.h2,{id:"dont-import-svgs-as-jsx-or-directly-in-react",children:"Don\u2019t import SVGs as JSX or directly in React"}),"\n",(0,o.jsx)(n.p,{children:"If you import a SVG like in the image above, you will include the SVGs into the bundle which will make the app slow to load."}),"\n",(0,o.jsx)(n.p,{children:"Each SVG has hundreds of elements so when React generates the Fiber tree, you will end up with a giant object with thousands of unnecessary data which will increase the memory consumption."}),"\n",(0,o.jsx)(n.h2,{id:"destructure-props-on-component-call",children:"Destructure Props on component call"}),"\n",(0,o.jsx)(n.h2,{id:"avoid-nested-ternary-operators",children:"Avoid Nested Ternary Operators"}),"\n",(0,o.jsx)(n.p,{children:"Nested ternaries are bad because they are hard to read and prone to errors."}),"\n",(0,o.jsx)(n.p,{children:"Ternary operators become hard to read after the first level."}),"\n",(0,o.jsx)(n.h2,{id:"use-composition-instead-of-context",children:"Use composition instead of Context"}),"\n",(0,o.jsx)(n.h2,{id:"use-virtualization-for-large-lists",children:"Use virtualization for large lists"}),"\n",(0,o.jsx)(n.p,{children:"Using virtualization in React can be highly beneficial for performance optimization, especially when dealing with large lists or tables. Virtualization is a technique that involves rendering only a small subset of the items in a list or table while giving the appearance of rendering the entire dataset. This is particularly useful when working with large amounts of data or when rendering a large number of components."}),"\n",(0,o.jsx)(n.h2,{id:"remove-all-the-listeners-when-unmounting-components",children:"Remove all the Listeners When Unmounting Components"}),"\n",(0,o.jsx)(n.p,{children:"Removing all event listeners when unmounting components in React is crucial to prevent memory leaks, improve performance, and avoid unexpected behavior. When you attach an event listener to a DOM element or a window object, it will persist even after the component is unmounted, unless you explicitly remove it."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-react",children:" useEffect(() => {\n    const handleClick = () => {\n      // do something on click\n    };\n\n    window.addEventListener('click', handleClick);\n\n    return () => {\n      window.removeEventListener('click', handleClick);\n    };\n  }, []);\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(6540);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);